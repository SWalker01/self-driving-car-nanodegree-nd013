<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>CBC User Guide</title><meta name="generator" content="DocBook XSL Stylesheets V1.61.2"></head><body><div class="book" xml:lang="en" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="cbcuserguide"></a>CBC User Guide</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">
    John
    </span> <span class="surname">
    Forrest
    </span></h3><div class="affiliation"><span class="orgname">
      IBM Research
      <br></span></div></div><div class="author"><h3 class="author"><span class="firstname">
    Robin
    </span> <span class="surname">
    Lougee-Heimer
    </span></h3><div class="affiliation"><span class="orgname">
      IBM Research
      <br></span></div></div></div></div><div><p class="copyright">Copyright Â© 2005 IBM Coportation</p></div><div><div class="legalnotice">
CBC and this documentation are provided under the terms of the 
<a href="http://opensource.org/licenses/cpl.php" target="_top">Common Public License
 ("CPL")</a>.  Any use, reproduction or distribution of the programs constitutes
the recipient's acceptance of the license.  The 
<a href="http://opensource.org/licenses/cpl.php" target="_top">CPL</a> is approved by
the <a href="http://opensource.org/" target="_top">Open Source Initiative</a>.  IBM
Corporation, the author of the
<a href="http://opensource.org/licenses/cpl.php" target="_top">CPL</a>, has a 
<a href="http://www.ibm.com/developerworks/library/os-cplfaq.html" target="_top">
CPL FAQ</a> available which is based on IBM's understanding of the 
<a href="http://opensource.org/licenses/cpl.php" target="_top">CPL</a>.
</div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt>1. <a href="#intro">
    Introduction
  </a></dt><dd><dl><dt><a href="#id3342315">
  Welcome to CBC
  </a></dt><dt><a href="#id3342145">
  Prerequisites
  </a></dt><dt><a href="#id3342019">Preliminaries</a></dt><dt><a href="#id3413036">
Branch-and-Cut Overview
</a></dt></dl></dd><dt>2. <a href="#cbcmodelclass">
   The CBC Model Class
  </a></dt><dd><dl><dt><a href="#hierarchy">
  Overview
  </a></dt><dt><a href="#firstexample">
  Simple Branch-and-Bound Example
  </a></dt><dt><a href="#osiAndCbc">
The Relationship Between OSI and CBC
</a></dt><dt><a href="#gettingsolution">
  Getting Solution Information
  </a></dt><dt><a href="#setsandgets">
   Useful Set and Get Methods in CbcModel
  </a></dt><dt><a href="#majormethods">
  Impacting the Solution Process
  </a></dt></dl></dd><dt>3. <a href="#otherclasses">
  Selecting the Next Node in the Search Tree
  </a></dt><dd><dl><dt><a href="#comparison">CbcCompare - Comparison Methods</a></dt></dl></dd><dt>4. <a href="#hueristicChap">
  Getting Good Bounds in CBC
  </a></dt><dd><dl><dt><a href="#heuristics">CbcHeuristic - Heuristic Methods</a></dt></dl></dd><dt>5. <a href="#branchChapter">
  Branching
 </a></dt><dd><dl><dt><a href="#branchingIntro">Branching Overview</a></dt><dt><a href="#branching">Pseudo Cost Branching</a></dt><dt><a href="#followOn">Follow-On Branching</a></dt></dl></dd><dt>6. <a href="#CutsChap">Cutting planes</a></dt><dd><dl><dt><a href="#cuts">Using Cut Generators with CBC</a></dt></dl></dd><dt>7. <a href="#SolverChap">
  Advanced Solver Uses
</a></dt><dd><dl><dt><a href="#solver">Creating a Solver via Inheritance</a></dt><dt><a href="#quadratic">Quadratic MIP</a></dt></dl></dd><dt>8. <a href="#moreexamples">
More Samples
</a></dt><dd><dl><dt><a href="#id3423737">CBC's Samples Directory</a></dt></dl></dd><dt>9. <a href="#messages">
  Messages
  </a></dt><dt>A. <a href="#id3430230">FAQ</a></dt><dt>B. <a href="#doxygen">Doxygen</a></dt><dt>C. <a href="#id3429980">Revision History</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="#assClasses">Associated Classes</a></dt><dt>2.1. <a href="#id3415008">
  Methods for Getting Solution Information from OSI 
  </a></dt><dt>2.2. <a href="#setGet">Useful Set and Get Methods in CbcModel</a></dt><dt>2.3. <a href="#id3416491">Classes Used by CbcModel - Most Useful</a></dt><dt>2.4. <a href="#least">Classes Used by CbcModel - Least Useful</a></dt><dt>3.1. <a href="#compareTable">Compare Classes Provided</a></dt><dt>3.2. <a href="#nodeTable">Information Available from CbcNode</a></dt><dt>8.1. <a href="#id3424694">Basic Samples</a></dt><dt>8.2. <a href="#id3424869">Advanced Samples</a></dt><dt>9.1. <a href="#id3426171">
  CBC Messages Passed At Log Level 0
  </a></dt><dt>9.2. <a href="#id3426316">
  CBC Messages Passed At or Above Log Level 1
  </a></dt><dt>9.3. <a href="#id3427680">
  CBC Messages Passed At or Above Log Level 2
  </a></dt><dt>9.4. <a href="#id3428080">
  CBC Messages Passed At or Above Log Level 3
  </a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>2.1. <a href="#minimum.cpp">minimum.cpp</a></dt><dt>3.1. <a href="#test">CbcCompareUser::test()</a></dt><dt>3.2. <a href="#newSolution">CbcCompareUser::newSolution()</a></dt><dt>3.3. <a href="#everyK">CbcCompareUser::every1000Nodes()</a></dt><dt>4.1. <a href="#id3421313">Data</a></dt><dt>4.2. <a href="#id3421342">Initialize newSolution</a></dt><dt>4.3. <a href="#id3421423">Create Feasible newSolution from Initial newSolution</a></dt><dt>4.4. <a href="#id3421467">Check Solution Quality of newSolution</a></dt><dt>5.1. <a href="#pseudo">CbcSimpleIntegerPseudoCosts</a></dt><dt>5.2. <a href="#id3421836">CbcFollowOn</a></dt><dt>7.1. <a href="#initialSolve">initialSolve()</a></dt><dt>7.2. <a href="#id3422104">First Few Solves</a></dt><dt>7.3. <a href="#id3422132">Create Small Sub-Problem</a></dt><dt>7.4. <a href="#id3422178">Check Optimal Solution</a></dt><dt>7.5. <a href="#id3422245">Solving a Quadratic MIP</a></dt></dl></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="intro"></a>Chapter&nbsp;1.&nbsp;
    Introduction
  </h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#id3342315">
  Welcome to CBC
  </a></dt><dt><a href="#id3342145">
  Prerequisites
  </a></dt><dt><a href="#id3342019">Preliminaries</a></dt><dt><a href="#id3413036">
Branch-and-Cut Overview
</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id3342315"></a>
  Welcome to CBC
  </h2></div></div><div></div></div><p>
  The COIN 
    <sup>[<a id="id3342326" href="#ftn.id3342326">1</a>]</sup>
Branch and Cut solver (CBC) is an open-source mixed-integer program 
(MIP) solver written  in C++. CBC is intended to be used primarily as a 
callable library to create customized branch-and-cut solvers. A basic, 
stand-alone  executable version is also available. CBC is an active 
open-source project led by John Forrest at www.coin-or.org.
 </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id3342145"></a>
  Prerequisites
  </h2></div></div><div></div></div><p>
  The primary users of CBC are expected to be developers implementing 
customized branch-and-cut algorithms in C++ using CBC as a library. 
Consequently, this document assumes a working knowledge of 
  <a href="http://www.cplusplus.com/doc/tutorial/" target="_top">C++</a>, including basic
  object-oriented programming terminology, and familiarity with the fundamental concepts of
  <a href="http://carbon.cudenver.edu/%7Ehgreenbe/courseware/LPshort/intro.html" target="_top">
  linear programming</a> (LP) and
  <a href="http://carbon.cudenver.edu/%7Ehgreenbe/courseware/MIP/intro.html" target="_top">
  mixed integer programming</a> (MIP). 
  </p><p>

CBC relies on other parts of the COIN repository. CBC needs a LP solver 
and relies on the COIN Open Solver Inteface (OSI) to communicate with 
the user's choice of solver. Any LP solver with an OSI interface can be 
used with CBC. The LP solver expected to be used most commonly is COIN's
 native linear program solver, CLP. For cut generators, CBC relies on 
the COIN Cut Generation Library (CGL). Any cut generator written to CGL 
standards can be used with CBC. Some of the cut generators in CGL rely 
on other parts of COIN, e.g., CGL's Gomory cut generator rely on the 
factorization functionality of <tt class="classname">CoinFactorization</tt>. This document assumes basic familiarity with OSI and CGL.
</p><p>
Technically speaking, CBC accesses the solver (and sometime the model and data it contains) through an <tt class="classname">OSISolverInterface</tt>. For the sake of simplicity, we will refer to the <tt class="classname">OsiSolverInterface</tt>
 as "the solver" in this document, rather than "the standard application
 programming interface to the solver." We hope any confusion caused by 
blurring this distinction will be mitigated by the shorter sentences.  
 
</p><p>
In summary, readers should have the following prerequisites:
   </p><div class="itemizedlist"><ul type="disc"><li>C++ knowledge,</li><li>LP and MIP fundamentals, and </li><li>OSI familiarity.</li></ul></div><p>
</p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id3342019"></a>Preliminaries</h2></div></div><div></div></div><p>
  </p><div class="itemizedlist"><ul type="disc"><li>Unless otherwise stated, the problem being optimized is a minimization problem. </li><li>The terms "model" and "problem" are used synonymously.</li><li>Notation: We use the convention of appending an underscore to 
              a variable in order to distinguish member data of a class.</li><li>The Cbc Samples directory, <tt class="filename">COIN/Cbc/Samples</tt> 
              contains the source code for the examples in the Guide.</li><li>The sample code in the Guide is written for illustrative 
              purposes of the CBC concepts and usage. The sample code is not 
              necessarily written for performance.</li></ul></div><p>
</p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id3413036"></a>
Branch-and-Cut Overview
</h2></div></div><div></div></div><p>
  Before examining CBC in more detail, we tersely describe the basic 
branch-and-cut algorithm by way of example, (which should really be 
called branch-and-cut-and-bound) and show the major C++ class(es) in CBC
 related to each step. The major CBC classes, labeled (A) through (F), 
are described in <a href="#assClasses" title="Table&nbsp;1.1.&nbsp;Associated Classes">Table&nbsp;1.1</a>.
 </p><p>
Step 1. (Bound) Given a MIP model to minimize where some variables must 
take on integer values (e.g., 0, 1, or 2), relax the integrality 
requirements (e.g., consider each "integer" variable to be continuous 
with a lower bound of 0.0 and an upper bound of 2.0). Solve the 
resulting linear model with an LP solver to obtain a lower bound on the 
MIP's objective function value.  If the optimal LP solution has integer 
values for the MIP's integer variables, we are finished. Any 
MIP-feasible solution provides an upper bound on the objective value. 
The upper bound equals the lower bound; the solution is optimal.   
 </p><p>  
Step 2. (Branch) Otherwise, there exists an "integer" variable with a 
non-integral value. Choose one non-integral variable (e.g., with value 
1.3) (A)(B) and branch. Create two 
<sup>[<a id="id3413203" href="#ftn.id3413203">2</a>]</sup>
nodes, one with the branching variable having an upper bound of 1.0, and
 the other with the branching variable having a lower bound of 2.0. Add 
the two nodes to the search tree.
 </p><p>
While (search tree is not empty) { 
</p><p> 
   Step 3. (Choose Node) Pick a node off the tree (C)(D)
</p><p>
   Step 4. (Re-optimize LP) Create an LP relaxation and solve.
</p><p>
   Step 5. (Bound) Interrogate the optimal LP solution, and try to prune the node by one of the following.
   </p><div class="itemizedlist"><ul type="disc"><li>
    LP is infeasible, prune the node.
    </li><li>
    Else, the optimal LP solution value of the node exceeds the current upper bound, prune the node.  
    </li><li>
    Else, the optimal LP solution of the node does not exceed the 
current upper bound and the solution is feasible to the MIP. Update the 
upper bound, and the best known MIP solution, and  prune the node by 
optimality.          
    </li></ul></div><p>  
</p><p>
   Step 6. (Branch) If we were unable to prune the node, then branch. 
Choose one non-integral variable to branch on (A)(B). Create two nodes 
and add them to the search tree.
}
 </p><p>      
This is the outline of a "branch-and-bound" algorithm. If in optimizing 
the linear programs, we use cuts to tighten the LP relaxations (E)(F), 
then we have a "branch-and-cut" algorithm. (Note, if cuts are only used 
in Step 1, the method is called a "cut-and-branch" algorithm.) 
  
  </p><div class="table"><a id="assClasses"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Associated Classes</b></p><table summary="Associated Classes" border="0"><colgroup><col><col><col></colgroup><thead><tr><th>
    Note
    </th><th>
    Class name
    </th><th>
    Description
    </th></tr></thead><tbody><tr><td align="left" valign="top">
      (A)
      </td><td align="left" valign="top"><tt class="classname">CbcBranch...</tt></td><td align="left" valign="top">
      These classes define the nature of MIP's discontinuity.  The simplest discontinuity
      is a variable which must take an integral value. Other types of discontinuities 
      exist, e.g., lot-sizing variables. 
      </td></tr><tr><td align="left" valign="top">
      (B)
      </td><td align="left" valign="top"><tt class="classname">CbcNode</tt></td><td align="left" valign="top">
      This class decides which variable/entity to branch on next.
      Even advanced users will probably only interact with this class by setting
      <tt class="classname">CbcModel</tt> parameters ( e.g., priorities).
      </td></tr><tr><td align="left" valign="top">
      (C)
      </td><td align="left" valign="top"><tt class="classname">CbcTree</tt></td><td align="left" valign="top">
      All unsolved models can be thought of as being nodes on a tree where each
      node (model) can branch two or more times. The interface with this class is helpful to know, but
the user can pretty safely ignore the inner workings of this class.
      </td></tr><tr><td align="left" valign="top">
      (D)
      </td><td align="left" valign="top"><tt class="classname">CbcCompare...</tt></td><td align="left" valign="top">
      These classes are used in determine which of the unexplored nodes in the tree to consider next. These
      classes are very small simple classes that can be tailored to suit the problem.
      </td></tr><tr><td align="left" valign="top">
      (E)
      </td><td align="left" valign="top"><tt class="classname">CglCutGenerators</tt></td><td align="left" valign="top">
      Any cut generator from CGL can be used in CBC. The cut generators are passed to CBC with parameters
      which modify when each generator will be tried. All cut generators should be tried to 
      determine which are effective. Few users will write their own cut generators.
      </td></tr><tr><td align="left" valign="top">
      (F)
      </td><td align="left" valign="top"><tt class="classname">CbcHeuristics</tt></td><td align="left" valign="top">
      Heuristics are very important for obtaining valid solutions quickly.  Some
      heuristics are available, but this is an area where it is useful and interesting to
      write specialized ones.
      </td></tr></tbody></table></div><p>
  There are a number of resources available to help new CBC users get started.
  This document is designed to be used in conjunction with the files in the
  Samples subdirectory of the main CBC directory (<tt class="filename">COIN/Cbc/Samples</tt>).
  The Samples illustrate how to use CBC and may also serve as useful starting points
  for user projects.  In the event that either this document or the available
  <a href="#doxygen" title="Appendix&nbsp;B.&nbsp;Doxygen">Doxygen content</a> conflicts with the observed
  behavior of the source code, the comments in the header files, found in
  <tt class="filename">COIN/Cbc/include</tt>, are the ultimate reference.
  </p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a id="ftn.id3342326" href="#id3342326">1</a>] </sup>
	The complete acronym is "COIN-OR" which stands for the Compuational 
Infrastructure for Operations Research. For simplicity (and in keeping 
with the directory and function names) we will simply use "COIN". 
	</p></div><div class="footnote"><p><sup>[<a id="ftn.id3413203" href="#id3413203">2</a>] </sup>
The current implementation of CBC allow two branches to be created. More general number of branches could be implemented.
</p></div></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="cbcmodelclass"></a>Chapter&nbsp;2.&nbsp;
   The CBC Model Class
  </h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#hierarchy">
  Overview
  </a></dt><dt><a href="#firstexample">
  Simple Branch-and-Bound Example
  </a></dt><dt><a href="#osiAndCbc">
The Relationship Between OSI and CBC
</a></dt><dt><a href="#gettingsolution">
  Getting Solution Information
  </a></dt><dt><a href="#setsandgets">
   Useful Set and Get Methods in CbcModel
  </a></dt><dt><a href="#majormethods">
  Impacting the Solution Process
  </a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="hierarchy"></a>
  Overview
  </h2></div></div><div></div></div><p>
  The main class in CBC is <tt class="classname">CbcModel</tt>.  The <tt class="classname">CbcModel</tt> class is where most
  of the parameter setting is done. The absolute minimum number of actions taken with <tt class="classname">CbcModel</tt> is two,
    </p><div class="itemizedlist"><ul type="disc"><li>
    <tt class="function">CbcModel(OsiSolverInterface &amp; linearSolver)</tt> as constructor, and
    </li><li>
    <tt class="function">branchAndBound()</tt> for solving the problem.    
    </li></ul></div><p>
  </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="firstexample"></a>
  Simple Branch-and-Bound Example
  </h2></div></div><div></div></div><p>
  The first sample program shows how to perform simple branch-and-bound 
with CBC.  This program is short enough to present in full.  Most of the
 remaining examples will take the form of small code fragments.
  The complete code for all the examples in this Guide can be found in 
the CBC Samples directory, <tt class="filename">COIN/Cbc/Samples</tt>.

  </p><div class="example"><a id="minimum.cpp"></a><p class="title"><b>Example&nbsp;2.1.&nbsp;minimum.cpp</b></p><pre class="programlisting">    
// Copyright (C) 2005, International Business Machines
// Corporation and others.  All Rights Reserved.

#include "CbcModel.hpp"

// Using CLP as the solver
#include "OsiClpSolverInterface.hpp"

int main (int argc, const char *argv[])
{
  OsiClpSolverInterface solver1;

  // Read in example model in MPS file format
  // and assert that it is a clean model
  int numMpsReadErrors = solver1.readMps("../../Mps/Sample/p0033.mps","");
  assert(numMpsReadErrors==0);

  // Pass the solver with the problem to be solved to CbcModel 
  CbcModel model(solver1);

  // Do complete search
  model.branchAndBound();

  /* Print the solution.  CbcModel clones the solver so we
     need to get current copy from the CbcModel */
  int numberColumns = model.solver()-&gt;getNumCols();
    
  const double * solution = model.bestSolution();
    
  for (int iColumn=0;iColumn&lt;numberColumns;iColumn++) {
    double value=solution[iColumn];
    if (fabs(value)&gt;1.0e-7&amp;&amp;model.solver()-&gt;isInteger(iColumn)) 
      printf("%d has value %g\n",iColumn,value);
   }
  return 0;
}    
     
  </pre></div><p>
  The program in <a href="#minimum.cpp" title="Example&nbsp;2.1.&nbsp;minimum.cpp">Example&nbsp;2.1</a> creates a <tt class="classname">OsiClpSolverInterface</tt> solver interface (i.e., <tt class="varname">solver1</tt>), and reads an MPS file. If there are no errors, the program passes the problem to <tt class="classname">CbcModel</tt>
 which solves the problem using the branch-and-bound algorithm. The part
 of the program which solves the problem is very small (one line!) but 
before that one line, the LP solver (i.e., <tt class="varname">solver1</tt>) had to be created and populated with the problem. After that one line, the results were printed out. 
 </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="osiAndCbc"></a>
The Relationship Between OSI and CBC
</h2></div></div><div></div></div><p> 
The program in <a href="#minimum.cpp" title="Example&nbsp;2.1.&nbsp;minimum.cpp">Example&nbsp;2.1</a> illustrates the dependency of CBC on  
  the <tt class="classname">OsiSolverInterface</tt> class. The constructor of <tt class="classname">CbcModel</tt> takes a pointer to an <tt class="classname">OsiSolverInterface</tt> (i.e., a solver). The <tt class="classname">CbcModel</tt> clones the solver, and uses its own instance of the solver. The <tt class="classname">CbcModel</tt>'s solver and the original solver (e.g., <tt class="varname">solver1</tt>) are not in sync unless the user synchronizes them. The user can always access the <tt class="classname">CbcModel</tt>'s solver through the <tt class="function">model()</tt> class.  To synchronize the two solvers, explicitly refreshing the original, e.g.,  
 </p><pre class="programlisting">  solver1 = model.solver();
</pre><p>
<tt class="classname">CbcModel</tt>'s method <tt class="function">solver()</tt> returns a pointer to CBC's cloned solver.
</p><p>
For convenience, many of the OSI methods to access problem data have identical method names in  <tt class="classname">CbcModel</tt>. (It's just more convenient to type <tt class="function">model.getNumCols()</tt> rather than <tt class="function">model.solver()-&gt;getNumCols()</tt>). The <tt class="classname">CbcModel</tt> refreshes its solver at certain logical points during the algorithm. At these points, the information from the <tt class="classname">CbcModel</tt> <tt class="varname">model</tt> will match the information from the <tt class="function">model.solver()</tt>. Elsewhere, the information may vary. For instance, the method <tt class="function">CbcModel::bestSolution()</tt> will contain the best solution so far, the OSI method <tt class="function">getColSolution()</tt> may not. In this case, it is safer to use <tt class="function">CbcModel::bestSolution()</tt>. 
</p><p>
While all the OSI methods used in <tt class="filename">minimum.cpp</tt> have equivalent methods in <tt class="classname">CbcModel</tt>,
 there are some OSI methods which do not. For example, if  the program 
produced a lot of undesired output, one might add the line 
</p><pre class="programlisting">  model.solver()-&gt;setHintParam(OsiDoReducePrint,true,OsiHintTry); 
</pre><p> 
  
  to reduce the output. There is no <tt class="function">setHintParam()</tt> method in <tt class="classname">CbcModel</tt>.
  </p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingsolution"></a>
  Getting Solution Information
  </h2></div></div><div></div></div><p>
  Optimality can be checked through a call to <tt class="function">model.isProvenOptimal()</tt>.  Also
  available are <tt class="function">isProvenInfeasible()</tt>,
  <tt class="function">isSolutionLimitReached()</tt>,
  <tt class="function">isNodeLimitReached()</tt> or the feared
  <tt class="function">isAbandoned()</tt>. There is also
  <tt class="function">int&nbsp;status()</tt> which returns 0 if 
finished (which includes the case when the algorithm is finished because
 it has been proved infeasible), 1 if stopped by user, and 2 if 
difficulties arose.
  </p><p>
  In addition to these <tt class="classname">CbcModel</tt> methods, solution values can be accessed via OSI methods.  The OSI methods pick up the current solution in the <tt class="classname">CBCModel</tt>.  The current solution will match the best solution found so far if called after <tt class="function">branchAndBound()</tt> and a solution was found. 
  </p><div class="table"><a id="id3415008"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;
  Methods for Getting Solution Information from OSI 
  </b></p><table summary="
  Methods for Getting Solution Information from OSI 
  " border="0"><colgroup><col><col></colgroup><thead><tr><th>
      Purpose
      </th><th>
      Name
      </th><th>
      Notes
      </th></tr></thead><tbody><tr><td align="left" valign="top">
      Primal column solution
      </td><td align="left" valign="top"><tt class="function">const double * getColSolution()</tt></td><td align="left" valign="top">
      The OSI method will return the best solution found thus far, unless none has been found. It is safer to use <tt class="classname">CbcModel</tt> version, <tt class="function">CbcModel::bestSolution()</tt></td></tr><tr><td align="left" valign="top">
      Dual row solution
      </td><td align="left" valign="top"><tt class="function">const double * getRowPrice()</tt></td><td align="left" valign="top">
      Identical <tt class="classname">CbcModel</tt> version available, <tt class="function">CbcModel::getRowPrice()</tt>.
      </td></tr><tr><td align="left" valign="top">
      Primal row solution
      </td><td align="left" valign="top"><tt class="function">const double * getRowActivity()</tt></td><td align="left" valign="top">
      Identical <tt class="classname">CbcModel</tt> version available, <tt class="function">CbcModel::getRowActivity()</tt>.
      </td></tr><tr><td align="left" valign="top">
      Dual column solution
      </td><td align="left" valign="top"><tt class="function">const double * getReducedCost()</tt></td><td align="left" valign="top">
      Identical <tt class="classname">CbcModel</tt> version available, <tt class="function">CbcModel::gtReducedCost()</tt>.
      </td></tr><tr><td align="left" valign="top">
      Number of rows in model
      </td><td align="left" valign="top"><tt class="function">int getNumRows()</tt></td><td align="left" valign="top">
      Identical <tt class="classname">CbcModel</tt> version available, <tt class="function">CbcModel::getNumRows()</tt>. Note: the number of rows can change due to cuts. 
      </td></tr><tr><td align="left" valign="top">
      Number of columns in model
      </td><td align="left" valign="top"><tt class="function">int getNumCols()</tt></td><td align="left" valign="top">
      Identical <tt class="classname">CbcModel</tt> version available, <tt class="function">CbcModel::getNumCols()</tt>.
      </td></tr></tbody></table></div></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="setsandgets"></a>
   Useful Set and Get Methods in <tt class="classname">CbcModel</tt>
  </h2></div></div><div></div></div><p>
Most of the parameter setting in CBC is done through <tt class="classname">CbcModel</tt> methods. The most commonly used set and get methods are listed in <a href="#setGet" title="Table&nbsp;2.2.&nbsp;Useful Set and Get Methods in CbcModel">Table&nbsp;2.2</a>.
</p><div class="table"><a id="setGet"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Useful Set and Get Methods in <tt class="classname">CbcModel</tt></b></p><table summary="Useful Set and Get Methods in CbcModel" border="0"><colgroup><col><col></colgroup><thead><tr><th>
    Method(s)
    </th><th>
    Description
    </th></tr></thead><tbody><tr><td align="left" valign="top"><tt class="function">bool&nbsp;setMaximumNodes(int value)</tt><br><tt class="function">int&nbsp;getMaximumNodes() const</tt><br><tt class="function">bool&nbsp;setMaximumSeconds(double value)</tt><br><tt class="function">double&nbsp;getMaximumSeconds()</tt><br><tt class="function">bool&nbsp;setMaximumSolutions(double value)</tt><br><tt class="function">double&nbsp;getMaximumSolutions() const</tt></td><td align="left" valign="top">
      These set methods tell CBC to stop after a given number of nodes,
      seconds, or solutions is reached. The get methods return the corresponding values.
      </td></tr><tr><td align="left" valign="top"><tt class="function">bool&nbsp;setIntegerTolerance(double value) const</tt><br><tt class="function">double&nbsp;getIntegerTolerance() const</tt></td><td align="left" valign="top">
      An integer variable is deemed to be at an integral value if it is no further than this <i class="parameter"><tt>value</tt></i> (tolerance) away. 
      </td></tr><tr><td align="left" valign="top"><tt class="function">bool&nbsp;setAllowableGap(double value)</tt><br><tt class="function">double&nbsp;getAllowableGap() const</tt><br><tt class="function">bool&nbsp;setAllowablePercentageGap(double value)</tt><br><tt class="function">double&nbsp;getAllowablePercentageGap() const</tt><br><tt class="function">bool&nbsp;setAllowableFractionGap(double value)</tt><br><tt class="function">double&nbsp;getAllowableFractionGap() const</tt><br></td><td align="left" valign="top"><tt class="classname">CbcModel</tt> returns if the gap between the best known solution and the best
      possible solution is less than this <i class="parameter"><tt>value</tt></i>, or as a percentage, or a fraction.
      </td></tr><tr><td align="left" valign="top"><tt class="function">void&nbsp;setNumberStrong(double value) </tt><br><tt class="function">int&nbsp;numberStrong()
<sup>[<a id="id3415743" href="#ftn.id3415743">a</a>]</sup> const </tt></td><td align="left" valign="top">
      These methods set or get the maximum number of candidates at a node to
      be evaluated for strong branching.
      </td></tr><tr><td align="left" valign="top"><tt class="function">void&nbsp;setPrintFrequency(int value) </tt><br><tt class="function">int&nbsp;printFrequency() const</tt></td><td align="left" valign="top">
      Controls the number of nodes evaluated between status prints.
      Print frequency has a very slight overhead, if <i class="parameter"><tt>value</tt></i> is small.
      </td></tr><tr><td align="left" valign="top"><tt class="function">int&nbsp;getNodeCount() const</tt></td><td align="left" valign="top">
      Returns number of nodes evaluated in the search.
      </td></tr><tr><td align="left" valign="top"><tt class="function">int&nbsp;numberRowsAtContinuous() const</tt></td><td align="left" valign="top">
      Returns number of rows in the problem when handed to the solver 
(i.e., before cuts where added). Commonly used in implementing 
heuristics.
      </td></tr><tr><td align="left" valign="top"><tt class="function">int &nbsp;numberIntegers() const</tt><br><tt class="function">const int&nbsp;*&nbsp;integerVariable() const</tt></td><td align="left" valign="top">
      Returns number of integer variables and an array specifying them. 
      </td></tr><tr><td align="left" valign="top"><tt class="function">bool&nbsp;isBinary(int colIndex) const</tt><br><tt class="function">bool&nbsp;isContinuous(int colIndex) const</tt><br><tt class="function">bool&nbsp;isInteger(int colIndex) const</tt></td><td align="left" valign="top">
      Returns information on variable <i class="parameter"><tt>colIndex</tt></i>. OSI methods
      can be used to set these attributes (before handing the model to <tt class="classname">CbcModel</tt>).
      </td></tr><tr><td align="left" valign="top"><tt class="function">double&nbsp;getObjValue() const</tt></td><td align="left" valign="top">
      This method returns the best objective value so far.
      </td></tr><tr><td align="left" valign="top"><tt class="function">double&nbsp;getCurrentObjValue() const</tt></td><td align="left" valign="top">
      This method returns the current objective value.
      </td></tr><tr><td align="left" valign="top"><tt class="function">const&nbsp;double&nbsp;*&nbsp;getObjCoefficients() const</tt><br></td><td align="left" valign="top">
      This method return the objective coefficients.
      </td></tr><tr><td align="left" valign="top"><tt class="function">const&nbsp;double&nbsp;*&nbsp;getRowLower() const</tt><br><tt class="function">const&nbsp;double&nbsp;*&nbsp;getRowUpper() const</tt><br><tt class="function">const&nbsp;double&nbsp;*&nbsp;getColLower() const</tt><br><tt class="function">const&nbsp;double&nbsp;*&nbsp;getColUpper() const</tt><br></td><td align="left" valign="top">
      These methods return the lower and upper bounds on row and column activities.
      </td></tr><tr><td align="left" valign="top"><tt class="function">const&nbsp;CoinPackedMatrix&nbsp;*&nbsp;getMatrixByRow() const</tt></td><td align="left" valign="top">
      This method returns a pointer to a row copy of matrix stored as a 
      <tt class="classname">CoinPackedMatrix</tt> which can be further examined.
      </td></tr><tr><td align="left" valign="top"><tt class="function">const CoinPackedMatrix * getMatrixByCol() const</tt></td><td align="left" valign="top">
      This method returns a pointer to a column copy of matrix stored as a
      <tt class="classname">CoinPackedMatrix</tt> which can be further examined.
      </td></tr><tr><td align="left" valign="top"><tt class="function">CoinBigIndex&nbsp;getNumElements() const</tt><sup>[<a id="id3416296" href="#ftn.id3416296">b</a>]</sup></td><td align="left" valign="top">
      Returns the number of nonzero elements in the problem matrix.
      </td></tr><tr><td align="left" valign="top"><tt class="function">void setObjSense(double&nbsp;value)</tt><br><tt class="function">double getObjSense() const</tt></td><td align="left" valign="top">
      These methods set and get the objective sense.  The parameter
      <i class="parameter"><tt>value</tt></i> should be +1 to minimize and -1 to maximize.
      </td></tr></tbody><tbody class="footnotes"><tr><td colspan="2"><div class="footnote"><p><sup>[<a id="ftn.id3415743" href="#id3415743">a</a>] </sup>
This methods (and some of the other) do not follow the "get" convention.
 The convention has changed over time and there are still some 
inconsistencies to be cleaned up.
</p></div><div class="footnote"><p><sup>[<a id="ftn.id3416296" href="#id3416296">b</a>] </sup> 
	<span class="type">CoinBigIndex</span> is a <tt class="function">typedef</tt> which in 
	most cases is the same as <span class="type">int</span>. 
	</p></div></td></tr></tbody></table></div></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="majormethods"></a>
  Impacting the Solution Process
  </h2></div></div><div></div></div><p>
<tt class="classname">CbcModel</tt> is extremely flexible and 
customizable. The class structure of CBC is designed to make the most 
commonly desired customizations of branch-and-cut possible. These 
include: 
    </p><div class="itemizedlist"><ul type="disc"><li>
     selecting the next node to consider in the search tree,
    </li><li>
    determining which variable to branch on,
    </li><li>
    using heuristics to generate MIP-feasible solutions quickly,
    </li><li>
    including cut generation when solving the LP-relaxations, and 
    </li><li>
    invoking customized subproblem solvers.
    </li></ul></div><p>


To enable this flexibility,  <tt class="classname">CbcModel</tt> uses 
other classes in CBC (some of which are virtual and may have multiple 
instances). Not all classes are created equal. The two tables below list
 in alphabetical order the classes used by <tt class="classname">CbcModel</tt> that are of most interest and of least interest. 
</p><div class="table"><a id="id3416491"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;Classes Used by CbcModel - Most Useful</b></p><table summary="Classes Used by CbcModel - Most Useful" border="0"><colgroup><col><col><col></colgroup><thead><tr><th>
    Class name 
    </th><th>
    Description
    </th><th>
    Notes
    </th></tr></thead><tbody><tr><td align="left" valign="top"><tt class="classname">CbcCompareBase</tt></td><td align="left" valign="top">
      Controls which node on the tree is selected.
      </td><td align="left" valign="top">
      The default is <tt class="classname">CbcCompareDefault</tt>. Other comparison classes in <tt class="filename">CbcCompareActual.hpp</tt> include <tt class="classname">CbcCompareDepth</tt> and <tt class="classname">CbcCompareObjective</tt>. Experimenting with these classes and creating new compare classes is easy.
      </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcCutGenerator</tt></td><td align="left" valign="top">
      A wrapper for <tt class="classname">CglCutGenerator</tt> with additional data to control when the cut generator is invoked during the tree search.
      </td><td align="left" valign="top">
      Other than knowing how to add a cut generator to <tt class="classname">CbcModel</tt>,
 there is not much the average user needs to know about this class. 
However, sophisticated users can implement their own cut generators. </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcHeuristic</tt></td><td align="left" valign="top">
      Heuristic that attempts to generate valid MIP-solutions leading to good upper bounds.
      </td><td align="left" valign="top">
      Specialized heuristics can dramatically improve branch-and-cut 
performance. As many different heuristics as desired can be used in CBC.
 Advanced users should consider implementing custom heuristics when 
tackling difficult problems. </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcObject</tt></td><td align="left" valign="top">
      Defines what it means for a variable to be satisfied. Used in branching.
      </td><td align="left" valign="top">
      Virtual class. CBC's concept of branching is based on the idea of 
an "object". An object has (i) a feasible region, (ii) can be evaluated 
for infeasibility, (iii) can be branched on, e.g., a method of 
generating a branching object, which defines an up branch and a down 
branch, and (iv) allows comparison of the effect of branching. Instances
 of objects include <tt class="classname">CbcSimpleInteger</tt>, <tt class="classname">CbcSimpleIntegerPseudoCosts</tt>, <tt class="classname">CbcClique</tt>, <tt class="classname">CbcSOS</tt> (type 1 and 2), <tt class="classname">CbcFollowOn</tt>, and <tt class="classname">CbcLotsize</tt>.
      </td></tr><tr><td align="left" valign="top"><tt class="classname">OsiSolverInterface</tt></td><td align="left" valign="top">
      Defines the LP solver being used and the LP model. Normally
      a pointer to the desired <tt class="classname">OsiSolverInteface</tt> is passed to <tt class="classname">CbcModel</tt> before branch and cut.
      </td><td align="left" valign="top">
      Virtual class. The user instantiates the solver interface of their choice, e.g., 
      <tt class="classname">OsiClpSolverInterface</tt>.
      </td></tr></tbody></table></div><p>
There is not much about the classes listed in <a href="#least" title="Table&nbsp;2.4.&nbsp;Classes Used by CbcModel - Least Useful">Table&nbsp;2.4</a> that the average user needs to know about. 
</p><div class="table"><a id="least"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;Classes Used by CbcModel - Least Useful</b></p><table summary="Classes Used by CbcModel - Least Useful" border="0"><colgroup><col><col><col></colgroup><thead><tr><th>
    Class name 
    </th><th>
    Description
    </th><th>
    Notes
    </th></tr></thead><tbody><tr><td align="left" valign="top"><tt class="classname">CbcBranchDecision</tt></td><td align="left" valign="top">
      Used in choosing which variable to branch on, however, most of 
      the work is done by the definitions in <tt class="classname">CbcObject</tt>.
      </td><td align="left" valign="top">
      Defaults to <tt class="classname">CbcBranchDefaultDecision</tt>. 
      </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcCountRowCut</tt></td><td align="left" valign="top">
      Interface to <tt class="classname">OsiRowCut</tt>. It counts the usage so cuts can gracefully vanish.
      </td><td align="left" valign="top">
      See <tt class="classname">OsiRowCut</tt> for more details. </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcNode</tt></td><td align="left" valign="top">
      Controls which variable/entity is selected to be branch on.
      </td><td align="left" valign="top">
      Controlled via <tt class="classname">CbcModel</tt> parameters. Information from <tt class="classname">CbcNode</tt> can be useful in creating customized node selection rules.  </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcNodeInfo</tt></td><td align="left" valign="top">
      Contains data on bounds, basis, etc. for one node of the search tree.
      </td><td align="left" valign="top">
      Header is located in <tt class="filename">CbcNode.hpp</tt>. </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcTree</tt></td><td align="left" valign="top">
      Defines how the search tree is stored.
      </td><td align="left" valign="top">
      This class can be changed but it is not likely to be modified.</td></tr><tr><td align="left" valign="top"><tt class="classname">CoinMessageHandler</tt></td><td align="left" valign="top">
      Deals with message handling
      </td><td align="left" valign="top">
      The user can inherit from <tt class="classname">CoinMessageHandler</tt> to specialize message handling.  
      </td></tr><tr><td align="left" valign="top"><tt class="classname">CoinWarmStartBasis</tt></td><td align="left" valign="top">
      Basis representation to be used by solver
      </td><td align="left" valign="top"></td></tr></tbody></table></div></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="otherclasses"></a>Chapter&nbsp;3.&nbsp;
  Selecting the Next Node in the Search Tree
  </h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#comparison">CbcCompare - Comparison Methods</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="comparison"></a>CbcCompare - Comparison Methods</h2></div></div><div></div></div><p>
  The order in which the nodes of the search tree are explored can 
strongly influence the performance of branch-and-cut algorithms. CBC 
give users complete control over the search order, including the ability
 to dynamically change the node selection logic as the search 
progresses. The search order is controlled via the <tt class="classname">CbcCompare...</tt> class, and its method <tt class="function">test()</tt>. Dynamic changes can be made whenever 
</p><div class="itemizedlist"><ul type="disc"><li>a new solution is found -- by customizing the method <tt class="function">newSolution()</tt>, or </li><li>every 1000 nodes -- by customizing the method <tt class="function">every1000Nodes()</tt>. </li></ul></div><p>
CBC provides an abstract base class, <tt class="classname">CbcCompareBase</tt>, and implementations of several commonly used node selection strategies as Compare Classes, see <a href="#compareTable" title="Table&nbsp;3.1.&nbsp;Compare Classes Provided">Table&nbsp;3.1</a>.
  </p><div class="table"><a id="compareTable"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Compare Classes Provided</b></p><table summary="Compare Classes Provided" border="0"><colgroup><col><col></colgroup><thead><tr><th>
    Class name 
    </th><th>
    Description
    </th></tr></thead><tbody><tr><td align="left" valign="top"><tt class="classname">CbcCompareDepth</tt></td><td align="left" valign="top">
      This will always choose the node deepest in tree.  It gives minimum
      tree size but may take a long time to find the best solution.
      </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcCompareObjective</tt></td><td align="left" valign="top">
      This will always choose the node with the best objective value.  This may
      give a very large tree.  It is likely that the first solution found
      will be the best and the search should finish soon after the first solution
      is found.
      </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcCompareDefault</tt></td><td align="left" valign="top">
      This is designed to do a mostly depth-first search until a 
solution has
      been found. It then use estimates that are designed to give a 
slightly better solution.
      If a reasonable number of nodes have been explored (or a 
reasonable number of
      solutions found), then this class will adopt a breadth-first 
search (i.e., making a comparison based strictly on objective function 
values) unless the tree is very large, in which case it will revert to 
depth-first search. A better description of <tt class="classname">CbcCompareUser</tt> is given below.
      </td></tr><tr><td align="left" valign="top"><tt class="classname">CbcCompareEstimate</tt></td><td align="left" valign="top">
      When pseudo costs are invoked, CBC uses the psuedo costs to guess a solution.  This class uses the guessed solution.
      </td></tr></tbody></table></div><p>
  It is relatively simple for a user to create a customized node 
selection by creating a new compare class instances. The code in <a href="#test" title="Example&nbsp;3.1.&nbsp;CbcCompareUser::test()">Example&nbsp;3.1</a> describes how to build a new comparison class and the reasoning behind it. The complete source can be found in <tt class="filename">CbcCompareUser.hpp</tt> and <tt class="filename">CbcCompareUser.cpp</tt>, located in the CBC Samples directory. Besides the constructor, the only method the user -must- implement in <tt class="classname">CbcCompare</tt> is <tt class="function">bool test(CbcNode* x, CbcNode* y))</tt> which returns <i class="parameter"><tt>true</tt></i> if node <i class="parameter"><tt>y</tt></i> is preferred over node <i class="parameter"><tt>x</tt></i>. In the <tt class="function">test()</tt> method, information from <tt class="classname">CbcNode</tt> can easily be used. <a href="#nodeTable" title="Table&nbsp;3.2.&nbsp;Information Available from CbcNode">Table&nbsp;3.2</a> lists some commonly used methods to access information at a node. 
  </p><div class="table"><a id="nodeTable"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Information Available from <tt class="classname">CbcNode</tt></b></p><table summary="Information Available from CbcNode" border="0"><colgroup><col><col></colgroup><tbody><tr><td align="left" valign="top"><tt class="function">double objectiveValue() const</tt></td><td align="left" valign="top">
      Value of objective at the node.
      </td></tr><tr><td align="left" valign="top"><tt class="function">int numberUnsatisfied() const</tt></td><td align="left" valign="top">
      Number of unsatisfied integers (assuming branching 
      object is an integer - otherwise it might be number of unsatisfied sets).
      </td></tr><tr><td align="left" valign="top"><tt class="function">int depth() const</tt></td><td align="left" valign="top">
       Depth of the node in the search tree.
      </td></tr><tr><td align="left" valign="top"><tt class="function">double guessedObjectiveValue() const</tt></td><td align="left" valign="top"> 
     Returns the guessed objective value, if the user was setting this (e.g., if using pseudo costs).
      </td></tr><tr><td align="left" valign="top"><tt class="function">int way() const</tt></td><td align="left" valign="top">
       The way which branching would next occur from this node
       (for more advanced use).
      </td></tr><tr><td align="left" valign="top"><tt class="function">int variable() const</tt></td><td align="left" valign="top">
       The branching "variable" (associated with the <tt class="classname">CbcBranchingObject</tt> -- for more advanced use).
      </td></tr></tbody></table></div><p>
</p><p>
The node desired in the tree is often a function of the how the search 
is progressing. In the design of CBC, there is no information on the 
state of the tree. The CBC is designed so that the method 
  <tt class="function">newSolution()</tt> is called whenever a solution is found and the method <tt class="function">every1000Nodes()</tt> is called every 1000 nodes.  When these methods are called, the user has the opportunity to modify the 
  behavior of <tt class="function">test()</tt> by adjusting their common variables (e.g., <tt class="varname">weight_</tt>). Because <tt class="classname">CbcNode</tt>
 has a pointer to the model, the user can also influence the search 
through actions such as changing the maximum time CBC is allowed, once a
 solution has been found (e.g., <tt class="function">CbcModel::setMaximumSeconds(double value)</tt>). In <tt class="filename">CbcCompareUser.cpp</tt> of the <tt class="filename">COIN/Cbc/Samples</tt> directory,  four items of data are used.
</p><p>
</p><div class="itemizedlist"><ul type="disc"><li><p>
1) The number of solutions found so far 
  </p></li><li><p>
2) The size of the tree (defined to be the number of active nodes)
  </p></li><li><p>
3) A weight, <tt class="varname">weight_</tt>, which is initialized to -1.0
  </p></li><li><p>
4) A saved value of weight, <tt class="varname">saveWeight_</tt> (for when weight is set back to -1.0 for special reason)
  </p></li></ul></div><p>
</p><p>
Initially, <tt class="varname">weight</tt>_ is -1.0 and the search is biased towards depth first.  In 
fact, <tt class="function">test()</tt> prefers <i class="parameter"><tt>y</tt></i> if <i class="parameter"><tt>y</tt></i> has fewer unsatisfied variables. In the case of a tie, <tt class="function">test()</tt> prefers the node with the greater depth in tree. The full code for the <tt class="function">CbcCompareUser::test()</tt> method is given in <a href="#test" title="Example&nbsp;3.1.&nbsp;CbcCompareUser::test()">Example&nbsp;3.1</a>.
</p><div class="example"><a id="test"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;<tt class="function">CbcCompareUser::test()</tt></b></p><pre class="programlisting">    
// Returns true if y better than x
bool 
CbcCompareUser::test (CbcNode * x, CbcNode * y)
{
  if (weight_==-1.0) {
    // before solution
    if (x-&gt;numberUnsatisfied() &gt; y-&gt;numberUnsatisfied())
      return true;
    else if (x-&gt;numberUnsatisfied() &lt; y-&gt;numberUnsatisfied())
      return false;
    else
      return x-&gt;depth() &lt; y-&gt;depth();
  } else {
    // after solution. 
    // note: if weight_=0, comparison is based 
    //       solely on objective value
    double weight = CoinMax(weight_,0.0);
    return x-&gt;objectiveValue()+ weight*x-&gt;numberUnsatisfied() &gt; 
      y-&gt;objectiveValue() + weight*y-&gt;numberUnsatisfied();
  }
}
     
  </pre></div><p>
CBC calls the method <tt class="function">newSolution()</tt> after a new solution is found. The method <tt class="function">newSolution()</tt> interacts with <tt class="function">test()</tt> by means of the variable <tt class="varname">weight_</tt>.
 If the solution was achieved by branching,  a calculation is made to 
determine the cost per unsatisfied integer variable to go from the 
continuous solution to an integer solution.  The variable <tt class="varname">weight_</tt> is then set to aim at a slightly better solution.  From then on, <tt class="function">test()</tt> returns <i class="parameter"><tt>true</tt></i> if it seems that <i class="parameter"><tt>y</tt></i> will lead to a better solution than <i class="parameter"><tt>x</tt></i>. This source for <tt class="function">newSolution()</tt> in given in <a href="#newSolution" title="Example&nbsp;3.2.&nbsp;CbcCompareUser::newSolution()">Example&nbsp;3.2</a>.
</p><div class="example"><a id="newSolution"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;<tt class="function">CbcCompareUser::newSolution()</tt></b></p><pre class="programlisting">    
// This allows the test() method to change behavior by resetting weight_.
// It is called after each new solution is found.
void 
CbcCompareUser::newSolution(CbcModel * model,
			       double objectiveAtContinuous,
			       int numberInfeasibilitiesAtContinuous) 
{
  if (model-&gt;getSolutionCount()==model-&gt;getNumberHeuristicSolutions())
    return; // The number of solutions found by any means equals the 
            // number of solutions, so this solution was found by rounding. 
            // Ignore it.

  // set weight_ to get close to this solution
  double costPerInteger = 
    (model-&gt;getObjValue()-objectiveAtContinuous)/
    ((double) numberInfeasibilitiesAtContinuous);
  weight_ = 0.98*costPerInteger; // this aims for a solution 
                                 // slightly better than known.
                                 // why 0.98? why not?! Experiment yourself.                                 
  saveWeight_=weight_; // We're going to switching between depth-first and breadth-first
                       // branching strategies, depending on what we find in the tree.
                       // When doing depth first, we'll want to retrieve this weight. 
                       // So, let's save it. 
  numberSolutions_++;
  if (numberSolutions_&gt;5)
    weight_ =0.0; // comparison in test() will be 
                  // based strictly on objective value.
}
     
  </pre></div><p>

As the search progresses, the comparison can be modified. If many nodes (or many solutions) have been generated, then <tt class="varname">weight_</tt>
 is set to 0.0 leading to a breadth-first search.  Breadth-first search 
can lead to an enormous tree. If the tree size is exceeds 10000, it may 
be desirable to return to a search biased towards depth first. Changing 
the behavior in this manner is done by the method <tt class="function">every1000Nodes</tt> shown in <a href="#everyK" title="Example&nbsp;3.3.&nbsp;CbcCompareUser::every1000Nodes()">Example&nbsp;3.3</a>.
  </p><div class="example"><a id="everyK"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;<tt class="function">CbcCompareUser::every1000Nodes()</tt></b></p><pre class="programlisting">    
// This allows the test() method to change behavior every 1000 nodes.
bool 
CbcCompareUser::every1000Nodes(CbcModel * model, int numberNodes)
{
  if (numberNodes&gt;10000) 
    weight_ =0.0; // compare nodes based on objective value
    // get size of tree
  treeSize_ = model-&gt;tree()-&gt;size();
  if (treeSize_&gt;10000) {
    // set weight to reduce size most of time
    if (treeSize_&gt;20000)
      weight_=-1.0;
    else if ((numberNodes%4000)!=0)  // Flip-flop between the strategies.
                                     // Why 4000? Why not? Experiment yourself.
      weight_=-1.0;
    else
      weight_=saveWeight_;
  }
  return numberNodes==11000; // resort if first time
}
     
  </pre></div></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="hueristicChap"></a>Chapter&nbsp;4.&nbsp;
  Getting Good Bounds in CBC
  </h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#heuristics">CbcHeuristic - Heuristic Methods</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="heuristics"></a>CbcHeuristic - Heuristic Methods</h2></div></div><div></div></div><p>
  In practice, it is very useful to get a good solution reasonably fast.
 Any MIP-feasible solution produces an upper bound, and a good bound 
will greatly reduce the run time. Good solutions can satisfy the user
  on very large problems where a complete search is impossible.  
Obviously, heuristics are
  problem dependent, although some do have more general use.
  At present there is only one heuristic in CBC itself, <tt class="classname">CbcRounding</tt>. Hopefully, the number will grow. Other heuristics are in the <tt class="filename">COIN/Cbc/Samples</tt>
  directory.  A heuristic tries to obtain a solution to the original
  problem so it only needs to consider the original rows and does not have to use the
  current bounds. CBC provides an abstract base class <tt class="classname">CbcHeuristic</tt> and a rounding heuristic in CBC. 
  </p><p>
  This chapter describes how to build a greedy heuristic for a set 
covering problem, e.g., the miplib problem fast0507. A more general (and
 efficient) version of the heuristic is in <tt class="filename">CbcHeuristicGreedy.hpp</tt> and <tt class="filename">CbcHeuristicGreedy.cpp</tt> located in the <tt class="filename">COIN/Cbc/Samples</tt> directory, see <a href="#moreexamples" title="Chapter&nbsp;8.&nbsp;
More Samples
">Chapter&nbsp;8, <i>
More Samples
</i></a>.
</p><p>
  The greedy heuristic will leave all variables taking value one at this
 node of the
  tree at value one, and will initially set all other variables to value
 zero.  
  All variables are then sorted in order of their cost
  divided by the number of entries in rows which are not yet covered. 
(We may randomize that
  value a bit so that ties will be broken in different ways on different
 runs of the heuristic.)
  The best one is choosen, and set to one. The process is repeated. 
Because this is
  a set covering problem (i.e., all constraints are â¥), the heuristic is
 guaranteed to find a solution (but not necessarily an improved 
solution). The speed of the heuristic could be improved by just redoing 
those affected, but for illustrative purposes we will keep it simple. 
(The speed could also be improved if all elements are 1.0). 
</p><p>
  The key <tt class="classname">CbcHeuristic</tt> method is <tt class="function">int&nbsp;solution(double &amp; solutionValue,
                                              double&nbsp;*&nbsp;betterSolution)</tt>.
  The <tt class="function">solution()</tt> method returns 0 if no 
solution found, and returns 1 if a solution is found, in which case it 
fills in the objective value and primal solution.  The code in <tt class="filename">CbcHeuristicGreedy.cpp</tt>
 is a little more complicated than this following example. For instance,
 the code here assumes all variables are integer.  The important bit of 
data is a copy of the matrix (stored by column) before any cuts have 
been made.  The data used are bounds, objective and the matrix plus two 
work arrays. 
  </p><div class="example"><a id="id3421313"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Data</b></p><pre class="programlisting">    
  OsiSolverInterface * solver = model_-&gt;solver(); // Get solver from CbcModel
  const double * columnLower = solver-&gt;getColLower(); // Column Bounds
  const double * columnUpper = solver-&gt;getColUpper();
  const double * rowLower = solver-&gt;getRowLower(); // We know we only need lower bounds
  const double * solution = solver-&gt;getColSolution();
  const double * objective = solver-&gt;getObjCoefficients(); // In code we also use min/max
  double integerTolerance = model_-&gt;getDblParam(CbcModel::CbcIntegerTolerance);
  double primalTolerance;
  solver-&gt;getDblParam(OsiPrimalTolerance,primalTolerance);
  int numberRows = originalNumberRows_; // This is number of rows when matrix was passed in
  // Column copy of matrix (before cuts)
  const double * element = matrix_.getElements();
  const int * row = matrix_.getIndices();
  const CoinBigIndex * columnStart = matrix_.getVectorStarts();
  const int * columnLength = matrix_.getVectorLengths();

  // Get solution array for heuristic solution
  int numberColumns = solver-&gt;getNumCols();
  double * newSolution = new double [numberColumns];
  // And to sum row activities
  double * rowActivity = new double[numberRows];
     
  </pre></div><p>
The <tt class="varname">newSolution</tt> is then initialized to the rounded down solution.
</p><div class="example"><a id="id3421342"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Initialize <tt class="varname">newSolution</tt></b></p><pre class="programlisting">    
  for (iColumn=0;iColumn&lt;numberColumns;iColumn++) {
    CoinBigIndex j;
    double value = solution[iColumn];
    // Round down integer
    if (fabs(floor(value+0.5)-value)&lt;integerTolerance) 
      value=floor(CoinMax(value+1.0e-3,columnLower[iColumn]));
    // make sure clean
    value = CoinMin(value,columnUpper[iColumn]);
    value = CoinMax(value,columnLower[iColumn]);
    newSolution[iColumn]=value;
    if (value) {
      double cost = objective[iColumn];
      newSolutionValue += value*cost;
      for (j=columnStart[iColumn];
           j&lt;columnStart[iColumn]+columnLength[iColumn];j++) {
        int iRow=row[j];
        rowActivity[iRow] += value*element[j];
      }
    }
  }
     
  </pre></div><p>


At this point some row activities are below their lower bound. To 
correct the infeasibility, the variable which is cheapest in reducing 
the sum of infeasibilities is found and updated, and the process 
repeats.  This is a finite process. (The implementation could be faster,
 but is kept simple for illustrative purposes.)
  </p><div class="example"><a id="id3421423"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Create Feasible <tt class="varname">newSolution</tt> from Initial <tt class="varname">newSolution</tt></b></p><pre class="programlisting">    
  while (true) {
    // Get column with best ratio
    int bestColumn=-1;
    double bestRatio=COIN_DBL_MAX;
    for (int iColumn=0;iColumn&lt;numberColumns;iColumn++) {
      CoinBigIndex j;
      double value = newSolution[iColumn];
      double cost = direction * objective[iColumn];
      // we could use original upper rather than current
      if (value+0.99&lt;columnUpper[iColumn]) {
        double sum=0.0; // Compute how much we will reduce infeasibility by
        for (j=columnStart[iColumn];
             j&lt;columnStart[iColumn]+columnLength[iColumn];j++) {
          int iRow=row[j];
          double gap = rowLower[iRow]-rowActivity[iRow];
          if (gap&gt;1.0e-7) {
            sum += CoinMin(element[j],gap);
          if (element[j]+rowActivity[iRow]&lt;rowLower[iRow]+1.0e-7) {
            sum += element[j];
	  }
	}
        if (sum&gt;0.0) {
	  double ratio = (cost/sum)*(1.0+0.1*CoinDrand48());
	  if (ratio&lt;bestRatio) {
            bestRatio=ratio;
            bestColumn=iColumn;
          }
	}
      }
    }
    if (bestColumn&lt;0)
      break; // we have finished
    // Increase chosen column
    newSolution[bestColumn] += 1.0;
    double cost = direction * objective[bestColumn];
    newSolutionValue += cost;
    for (CoinBigIndex j=columnStart[bestColumn];
         j&lt;columnStart[bestColumn]+columnLength[bestColumn];j++) {
      int iRow = row[j];
      rowActivity[iRow] += element[j];
    }
  }
     
  </pre></div><p>
A solution value of <tt class="varname">newSolution</tt> is compared to the best solution value. If <tt class="varname">newSolution</tt> is an improvement, its feasibility is validated. We expect <tt class="varname">newSolution</tt> to be feasible, and are trapping for unexpected numerical errors.
  </p><div class="example"><a id="id3421467"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Check Solution Quality of <tt class="varname">newSolution</tt></b></p><pre class="programlisting">    
  returnCode=0; // 0 means no good solution
  if (newSolutionValue&lt;solutionValue) { // minimization
    // check feasible
    memset(rowActivity,0,numberRows*sizeof(double));
    for (iColumn=0;iColumn&lt;numberColumns;iColumn++) {
      CoinBigIndex j;
      double value = newSolution[iColumn];
      if (value) {
	for (j=columnStart[iColumn];
	     j&lt;columnStart[iColumn]+columnLength[iColumn];j++) {
	  int iRow=row[j];
	  rowActivity[iRow] += value*element[j];
	}
      }
    }
    // check was approximately feasible
    bool feasible=true;
    for (iRow=0;iRow&lt;numberRows;iRow++) {
      if(rowActivity[iRow]&lt;rowLower[iRow]) {
	if (rowActivity[iRow]&lt;rowLower[iRow]-10.0*primalTolerance)
	  feasible = false;
      }
    }
    if (feasible) {
      // new solution
      memcpy(betterSolution,newSolution,numberColumns*sizeof(double));
      solutionValue = newSolutionValue;
      // We have good solution
      returnCode=1;
    }
  }
     
  </pre></div></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="branchChapter"></a>Chapter&nbsp;5.&nbsp;
  Branching
 </h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#branchingIntro">Branching Overview</a></dt><dt><a href="#branching">Pseudo Cost Branching</a></dt><dt><a href="#followOn">Follow-On Branching</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="branchingIntro"></a>Branching Overview</h2></div></div><div></div></div><p>
CBC's concept of branching is based on the idea of an "object". An 
object has (i) a feasible region, (ii) can be evaluated for 
infeasibility, (iii) can be branched on, e.g., a method of generating a 
branching object, which defines an up branch and a down branch, and (iv)
 allows comparsion of the effect of branching. Instances of objects 
include.
</p><div class="itemizedlist"><ul type="disc"><li><tt class="classname">CbcSimpleInteger</tt>, </li><li><tt class="classname">CbcSimpleIntegerPseudoCosts</tt>,  </li><li><tt class="classname">CbcClique</tt>, </li><li><tt class="classname">CbcSOS</tt> (type 1 and 2), </li><li><tt class="classname">CbcFollowOn</tt>, and </li><li><tt class="classname">CbcLotsize</tt>.</li></ul></div><p>
In <a href="#branchChapter" title="Chapter&nbsp;5.&nbsp;
  Branching
 ">Chapter&nbsp;5, <i>
  Branching
 </i></a>, we give examples of how to use existing branching objects. 
(The next revision of this Guide should include an example of how to 
write your own branching object; Contributions of examples are welcome.)
</p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="branching"></a>Pseudo Cost Branching</h2></div></div><div></div></div><p>

If the user declares variables as integer but does no more, then CBC 
will treat them
as simple integer variables.  In many cases the user would like to do 
some more fine tuning. This section shows how to create integer 
variables with pseudo costs.  When pseudo costs are given then 
it is assumed that if a variable is at 1.3 then the cost of branching 
that variable down will be 0.3 times the down pseudo cost and the cost 
of branching up would be 0.7 times the up pseudo cost.  Pseudo costs can
 be used both for branching and for choosing a node.
   The full code is in <tt class="filename">longthin.cpp</tt> located in the CBC Samples directory, see
  <a href="#moreexamples" title="Chapter&nbsp;8.&nbsp;
More Samples
">Chapter&nbsp;8, <i>
More Samples
</i></a>.
</p><p>  
  The idea is simple for set covering problems.
  Branching up gets us much closer to an integer solution so we will 
encourage that direction by branch up if variable value &gt; 0.333333.
  The expected cost of going up obviously depends on the cost of the
  variable. The pseudo costs are choosen to reflect that fact.

  </p><div class="example"><a id="pseudo"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;<tt class="classname">CbcSimpleIntegerPseudoCosts</tt></b></p><pre class="programlisting">    
  int iColumn;
  int numberColumns = solver3-&gt;getNumCols();
  // do pseudo costs
  CbcObject ** objects = new CbcObject * [numberColumns];
  // Point to objective
  const double * objective = model.getObjCoefficients();
  int numberIntegers=0;
  for (iColumn=0;iColumn&lt;numberColumns;iColumn++) {
    if (solver3-&gt;isInteger(iColumn)) {
      double cost = objective[iColumn];
      CbcSimpleIntegerPseudoCost * newObject =
        new CbcSimpleIntegerPseudoCost(&amp;model,numberIntegers,iColumn,
                                       2.0*cost,cost);
      newObject-&gt;setMethod(3);
      objects[numberIntegers++]= newObject;
    }
  }
  // Now add in objects (they will replace simple integers)
  model.addObjects(numberIntegers,objects);
  for (iColumn=0;iColumn&lt;numberIntegers;iColumn++)
    delete objects[iColumn];
  delete [] objects;
     
  </pre></div><p>
The code in <a href="#pseudo" title="Example&nbsp;5.1.&nbsp;CbcSimpleIntegerPseudoCosts">Example&nbsp;5.1</a> also tries to give more importance to variables with more 
coefficients.  Whether this sort of thing is worthwhile should be the subject of experimentation.


</p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="followOn"></a>Follow-On Branching</h2></div></div><div></div></div><p>
In crew scheduling, the problems are long and thin. A problem may have a
 few rows but many thousands of variables.  Branching a variable to 1 is
 very powerful as it fixes many other variables to zero, but branching 
to zero is very weak as thousands of variables can increase from zero.  
In crew scheduling problems, each constraint is a flight leg, e.g., JFK 
airport to DFW airport.
From DFW there may be several flights the crew could take next - suppose
 one flight is 
the 9:30 flight from DFW to LAX airport.  A binary branch is that the 
crew arriving 
at DFW either take the 9:30 flight to LAX or they don't.  This 
"follow-on" branching does not
fix individual variables. Instead this branching divides all the 
variables with entries in the JFK-DFW 
constraint into two groups - those with entries in the DFW-LAX 
constraint and those without
entries.
</p><p>
   The full sample code for follow-on brancing is in <tt class="filename">crew.cpp</tt>
  located in the CBC Samples directory, see
  <a href="#moreexamples" title="Chapter&nbsp;8.&nbsp;
More Samples
">Chapter&nbsp;8, <i>
More Samples
</i></a>).  In this case, the simple integer
variables are left which may be necessary if other sorts of constraints 
exist. Follow-on branching rules are to be considered first, so the 
priorities are set to indicate the follow-on rules take precedence. 
Priority 1 is the highest priority.

</p><div class="example"><a id="id3421836"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;<tt class="classname">CbcFollowOn</tt></b></p><pre class="programlisting">    
  int iColumn;
  int numberColumns = solver3-&gt;getNumCols();
  /* We are going to add a single follow-on object but we
     want to give low priority to existing integers 
     As the default priority is 1000 we don't actually need to give
     integer priorities but it is here to show how.
  */
  // Normal integer priorities
  int * priority = new int [numberColumns];
  int numberIntegers=0;
  for (iColumn=0;iColumn&lt;numberColumns;iColumn++) {
    if (solver3-&gt;isInteger(iColumn)) {
      priority[numberIntegers++]= 100; // low priority
    }
  }
  /* Second parameter is set to true for objects,
     and false for integers. This indicates integers */
  model.passInPriorities(priority,false);
  delete [] priority;
  /* Add in objects before we can give them a priority.
     In this case just one object
     - but it shows the general method
  */
  CbcObject ** objects = new CbcObject * [1];
  objects[0]=new CbcFollowOn(&amp;model);
  model.addObjects(1,objects);
  delete objects[0];
  delete [] objects;
  // High priority
  int followPriority=1;
  model.passInPriorities(&amp;followPriority,true);
     
  </pre></div></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="CutsChap"></a>Chapter&nbsp;6.&nbsp;Cutting planes</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#cuts">Using Cut Generators with CBC</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="cuts"></a>Using Cut Generators with CBC</h2></div></div><div></div></div><p>
In the next version of this Guide, we need to have an example 
illustrating how to use COIN's CGL with CBC. Contribtions are welcome. 

  </p></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="SolverChap"></a>Chapter&nbsp;7.&nbsp;
  Advanced Solver Uses
</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#solver">Creating a Solver via Inheritance</a></dt><dt><a href="#quadratic">Quadratic MIP</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="solver"></a>Creating a Solver via Inheritance</h2></div></div><div></div></div><p>
  CBC uses a generic <tt class="classname">OsiSolverInterface</tt> and its <tt class="function">resolve</tt>
 capability.
  This does not give much flexibility so advanced users can inherit from
 their interface
  of choice.  This section illustrates how to implement a specialized 
solver for a long thin problem, e.g., fast0507 again.  As with the other
 examples in the Guide, the sample code is not guaranteed to be the 
fastest way to solve the problem. The main purpose of the example is to 
illustrate techniques. The full source is in <tt class="filename">CbcSolver2.hpp</tt> and <tt class="filename">CbcSolver2.cpp</tt> located in the CBC Samples directory, see
  <a href="#moreexamples" title="Chapter&nbsp;8.&nbsp;
More Samples
">Chapter&nbsp;8, <i>
More Samples
</i></a>. 
</p><p>
The method <tt class="function">initialSolve</tt> is called a few times in CBC, and provides a convenient starting point. The <tt class="varname">modelPtr_</tt> derives from <tt class="classname">OsiClpSolverInterface</tt>.
  </p><div class="example"><a id="initialSolve"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;<tt class="function">initialSolve()</tt></b></p><pre class="programlisting">    
  // modelPtr_ is of type ClpSimplex *
  modelPtr_-&gt;setLogLevel(1); // switch on a bit of printout
  modelPtr_-&gt;scaling(0); // We don't want scaling for fast0507
  setBasis(basis_,modelPtr_); // Put basis into ClpSimplex
  // Do long thin by sprint
  ClpSolve options;
  options.setSolveType(ClpSolve::usePrimalorSprint);
  options.setPresolveType(ClpSolve::presolveOff);
  options.setSpecialOption(1,3,15); // Do 15 sprint iterations
  modelPtr_-&gt;initialSolve(options); // solve problem
  basis_ = getBasis(modelPtr_); // save basis
  modelPtr_-&gt;setLogLevel(0); // switch off printout
     
  </pre></div><p>
The <tt class="function">resolve()</tt> method is more complicated than <tt class="function">initialSolve()</tt>.  The main pieces of data are a counter <tt class="varname">count_</tt> which is incremented each solve and an integer array <tt class="varname">node_</tt> which stores the last time
a variable was active in a solution.  For the first few solves, the normal Dual Simplex is called and
<tt class="varname">node_</tt> array is updated.
</p><div class="example"><a id="id3422104"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;First Few Solves</b></p><pre class="programlisting">    
  if (count_&lt;10) {
    OsiClpSolverInterface::resolve(); // Normal resolve
    if (modelPtr_-&gt;status()==0) {
      count_++; // feasible - save any nonzero or basic
      const double * solution = modelPtr_-&gt;primalColumnSolution();
      for (int i=0;i&lt;numberColumns;i++) {
	if (solution[i]&gt;1.0e-6||modelPtr_-&gt;getStatus(i)==ClpSimplex::basic) {
	  node_[i]=CoinMax(count_,node_[i]);
	  howMany_[i]++;
	}
      }
    } else {
      printf("infeasible early on\n");
    }
  }
     
  </pre></div><p>
After the first few solves, only those variables which took part in a solution in the last so many
solves are used.  As fast0507 is a set covering problem, any rows which are already covered can be taken out.
  </p><div class="example"><a id="id3422132"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;Create Small Sub-Problem</b></p><pre class="programlisting">    
    int * whichRow = new int[numberRows]; // Array to say which rows used
    int * whichColumn = new int [numberColumns]; // Array to say which columns used
    int i;
    const double * lower = modelPtr_-&gt;columnLower();
    const double * upper = modelPtr_-&gt;columnUpper();
    setBasis(basis_,modelPtr_); // Set basis
    int nNewCol=0; // Number of columns in small model
    // Column copy of matrix
    const double * element = modelPtr_-&gt;matrix()-&gt;getElements();
    const int * row = modelPtr_-&gt;matrix()-&gt;getIndices();
    const CoinBigIndex * columnStart = modelPtr_-&gt;matrix()-&gt;getVectorStarts();
    const int * columnLength = modelPtr_-&gt;matrix()-&gt;getVectorLengths();
    
    int * rowActivity = new int[numberRows]; // Number of columns with entries in each row
    memset(rowActivity,0,numberRows*sizeof(int));
    int * rowActivity2 = new int[numberRows]; // Lower bound on row activity for each row
    memset(rowActivity2,0,numberRows*sizeof(int));
    char * mark = (char *) modelPtr_-&gt;dualColumnSolution(); // Get some space to mark columns
    memset(mark,0,numberColumns);
    for (i=0;i&lt;numberColumns;i++) {
      bool choose = (node_[i]&gt;count_-memory_&amp;&amp;node_[i]&gt;0); // Choose if used recently
      // Take if used recently or active in some sense
      if ((choose&amp;&amp;upper[i])
	  ||(modelPtr_-&gt;getStatus(i)!=ClpSimplex::atLowerBound&amp;&amp;
             modelPtr_-&gt;getStatus(i)!=ClpSimplex::isFixed)
	  ||lower[i]&gt;0.0) {
        mark[i]=1; // mark as used
	whichColumn[nNewCol++]=i; // add to list
        CoinBigIndex j;
        double value = upper[i];
        if (value) {
          for (j=columnStart[i];
               j&lt;columnStart[i]+columnLength[i];j++) {
            int iRow=row[j];
            assert (element[j]==1.0);
            rowActivity[iRow] ++; // This variable can cover this row
          }
          if (lower[i]&gt;0.0) {
            for (j=columnStart[i];
                 j&lt;columnStart[i]+columnLength[i];j++) {
              int iRow=row[j];
              rowActivity2[iRow] ++; // This row redundant
            }
          }
        }
      }
    }
    int nOK=0; // Use to count rows which can be covered
    int nNewRow=0; // Use to make list of rows needed
    for (i=0;i&lt;numberRows;i++) {
      if (rowActivity[i])
        nOK++;
      if (!rowActivity2[i])
        whichRow[nNewRow++]=i; // not satisfied
      else
        modelPtr_-&gt;setRowStatus(i,ClpSimplex::basic); // make slack basic
    }
    if (nOK&lt;numberRows) {
      // The variables we have do not cover rows - see if we can find any that do
      for (i=0;i&lt;numberColumns;i++) {
        if (!mark[i]&amp;&amp;upper[i]) {
          CoinBigIndex j;
          int good=0;
          for (j=columnStart[i];
               j&lt;columnStart[i]+columnLength[i];j++) {
            int iRow=row[j];
            if (!rowActivity[iRow]) {
              rowActivity[iRow] ++;
              good++;
            }
          }
          if (good) {
            nOK+=good; // This covers - put in list
            whichColumn[nNewCol++]=i;
          }
        }
      }
    }
    delete [] rowActivity;
    delete [] rowActivity2;
    if (nOK&lt;numberRows) {
      // By inspection the problem is infeasible - no need to solve
      modelPtr_-&gt;setProblemStatus(1);
      delete [] whichRow;
      delete [] whichColumn;
      printf("infeasible by inspection\n");
      return;
    }
    // Now make up a small model with the right rows and columns
    ClpSimplex *  temp = new ClpSimplex(modelPtr_,nNewRow,whichRow,nNewCol,whichColumn);
     
  </pre></div><p>
If the variables cover the rows, then the problem is feasible (no cuts 
are being used). (If the rows
were equality constraints, then this might not be the case. More work 
would be needed.)  After the solution to the subproblem, the reduced 
costs of the full problem are checked. If the reduced cost of any 
variable not in the subproblem is negative, the code goes back to the 
full problem and cleans up with Primal Simplex.
  </p><div class="example"><a id="id3422178"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;Check Optimal Solution</b></p><pre class="programlisting">    
    temp-&gt;setDualObjectiveLimit(1.0e50); // Switch off dual cutoff as problem is restricted
    temp-&gt;dual(); // solve
    double * solution = modelPtr_-&gt;primalColumnSolution(); // put back solution
    const double * solution2 = temp-&gt;primalColumnSolution();
    memset(solution,0,numberColumns*sizeof(double));
    for (i=0;i&lt;nNewCol;i++) {
      int iColumn = whichColumn[i];
      solution[iColumn]=solution2[i];
      modelPtr_-&gt;setStatus(iColumn,temp-&gt;getStatus(i));
    }
    double * rowSolution = modelPtr_-&gt;primalRowSolution();
    const double * rowSolution2 = temp-&gt;primalRowSolution();
    double * dual = modelPtr_-&gt;dualRowSolution();
    const double * dual2 = temp-&gt;dualRowSolution();
    memset(dual,0,numberRows*sizeof(double));
    for (i=0;i&lt;nNewRow;i++) {
      int iRow=whichRow[i];
      modelPtr_-&gt;setRowStatus(iRow,temp-&gt;getRowStatus(i));
      rowSolution[iRow]=rowSolution2[i];
      dual[iRow]=dual2[i];
    }
    // See if optimal
    double * dj = modelPtr_-&gt;dualColumnSolution();
    // get reduced cost for large problem
    // this assumes minimization
    memcpy(dj,modelPtr_-&gt;objective(),numberColumns*sizeof(double));
    modelPtr_-&gt;transposeTimes(-1.0,dual,dj);
    modelPtr_-&gt;setObjectiveValue(temp-&gt;objectiveValue());
    modelPtr_-&gt;setProblemStatus(0);
    int nBad=0;
      
    for (i=0;i&lt;numberColumns;i++) {
      if (modelPtr_-&gt;getStatus(i)==ClpSimplex::atLowerBound
          &amp;&amp;upper[i]&gt;lower[i]&amp;&amp;dj[i]&lt;-1.0e-5)
        nBad++;
    }
    // If necessary clean up with primal (and save some statistics)
    if (nBad) {
      timesBad_++;
      modelPtr_-&gt;primal(1);
      iterationsBad_ += modelPtr_-&gt;numberIterations();
    }
     
  </pre></div><p>
The array <tt class="varname">node_</tt> is updated, as for the first 
few solves.  To give some idea of the effect of this tactic, the problem
 fast0507 has 63,009 variables but the small problem never has more than
 4,000 variables. In only about ten percent of solves was it necessary 
to resolve, and then the average number of iterations
on full problem was less than 20.
</p></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="quadratic"></a>Quadratic MIP</h2></div></div><div></div></div><p>
To give another example - again only for illustrative purposes -- it is possible to do quadratic
MIP with CBC.  In this case, we make <tt class="function">resolve</tt> the same as 
<tt class="function">initialSolve</tt>.
   The full code is in <tt class="filename">ClpQuadInterface.hpp</tt> and
   <tt class="filename">ClpQuadInterface.cpp</tt> located in the CBC Samples directory, see
  <a href="#moreexamples" title="Chapter&nbsp;8.&nbsp;
More Samples
">Chapter&nbsp;8, <i>
More Samples
</i></a>).
  </p><div class="example"><a id="id3422245"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;Solving a Quadratic MIP</b></p><pre class="programlisting">    
  // save cutoff
  double cutoff = modelPtr_-&gt;dualObjectiveLimit();
  modelPtr_-&gt;setDualObjectiveLimit(1.0e50);
  modelPtr_-&gt;scaling(0);
  modelPtr_-&gt;setLogLevel(0);
  // solve with no objective to get feasible solution
  setBasis(basis_,modelPtr_);
  modelPtr_-&gt;dual();
  basis_ = getBasis(modelPtr_);
  modelPtr_-&gt;setDualObjectiveLimit(cutoff);
  if (modelPtr_-&gt;problemStatus()) 
    return; // problem was infeasible 
  // Now pass in quadratic objective
  ClpObjective * saveObjective  = modelPtr_-&gt;objectiveAsObject();
  modelPtr_-&gt;setObjectivePointer(quadraticObjective_);
  modelPtr_-&gt;primal(); // Th model has a quadratic objective, 
                       // so this invokes quadratic primal.
  modelPtr_-&gt;setDualObjectiveLimit(cutoff);
  if (modelPtr_-&gt;objectiveValue()&gt;cutoff)
    modelPtr_-&gt;setProblemStatus(1);
  modelPtr_-&gt;setObjectivePointer(saveObjective);
     
  </pre></div><p>
Rather than implementing all the method from scratch, we based the quadratic solver <tt class="classname">ClpQuadInteface</tt> on the linear programming solver <tt class="classname">OsiClpSolverInterface</tt>.
 This is a convenient approach to take when prototyping ideas. After the
 merit of an idea is proven, the user can decide is a more serious 
implementation is warranted.
</p></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="moreexamples"></a>Chapter&nbsp;8.&nbsp;
More Samples
</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#id3423737">CBC's Samples Directory</a></dt></dl></div><div class="section" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id3423737"></a>CBC's Samples Directory</h2></div></div><div></div></div><p>
The CBC distribution includes a number of <tt class="filename">.cpp</tt> sample files.
Users are encouraged to use them as starting points for their own CBC projects.
The files can be found in the <tt class="filename">COIN/Cbc/Samples/</tt> directory.
For the latest information on compiling and running these samples, please see
the file <tt class="filename">COIN/Cbc/Samples/INSTALL</tt>.  Most of them can be built
by </p><pre class="programlisting">make DRIVER=name</pre><p> which produces an executable <tt class="filename">testit</tt>.  Below is a list of
some of the most useful sample files with a short description for each file.
</p><div class="table"><a id="id3424694"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Basic Samples</b></p><table summary="Basic Samples" border="0"><colgroup><col><col></colgroup><thead><tr><th align="left" valign="bottom">
	Source file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</th><th align="left" valign="bottom">
	Description
	</th></tr></thead><tbody><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/minimum.cpp" target="_top"><tt class="filename">minimum.cpp</tt></a></td><td align="left" valign="top">
	This is a CBC "Hello, world" program.  It reads a problem
	in MPS file format, and solves the problem using simple branch-and-bound.
	</td></tr><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/sample2.cpp" target="_top"><tt class="filename">sample2.cpp</tt></a></td><td align="left" valign="top">
	This is designed to be a file that a user could modify to get a useful
	driver program for his or her project.  In particular, it demonstrates
	the use of CGL's  preprocess functionality.
        It uses <tt class="function">CbcBranchUser.cpp</tt>,
        <tt class="function">CbcCompareUser.cpp</tt> and
        <tt class="function">CbcHeuristicUser.cpp</tt> 
        with corresponding <tt class="function">*.hpp</tt> files.
	</td></tr></tbody></table></div><div class="table"><a id="id3424869"></a><p class="title"><b>Table&nbsp;8.2.&nbsp;Advanced Samples</b></p><table summary="Advanced Samples" border="0"><colgroup><col><col></colgroup><thead><tr><th align="left" valign="bottom">
	Source file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	</th><th align="left" valign="bottom">
	Description
	</th></tr></thead><tbody><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/crew.cpp" target="_top"><tt class="filename">crew.cpp</tt></a></td><td align="left" valign="top">
	This sample shows the use of advanced branching and a use of priorities.
        It uses <tt class="function">CbcCompareUser.cpp</tt>
        with corresponding <tt class="function">*.hpp</tt> files.
	</td></tr><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/longthin.cpp" target="_top"><tt class="filename">longthin.cpp</tt></a></td><td align="left" valign="top">
	This sample shows the advanced use of a solver.  It also has coding for
	a greedy heuristic.
        The solver is given in <tt class="function">CbcSolver2.hpp</tt> and
        <tt class="function">CbcSolver2.cpp</tt>.
        The heuristic is given in <tt class="function">CbcHeuristicGreedy.hpp</tt> and
        <tt class="function">CbcHeuristicGreedy.cpp</tt>.
        It uses <tt class="function">CbcBranchUser.cpp</tt> and
        <tt class="function">CbcCompareUser.cpp</tt>
        with corresponding <tt class="function">*.hpp</tt> files.
	</td></tr><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/qmip.cpp" target="_top"><tt class="filename">qmip.cpp</tt></a></td><td align="left" valign="top">
	This solves a quadratic MIP.  It is to show advanced use of a solver.
        The solver is given in <tt class="function">ClpQuadInterface.hpp</tt> and
        <tt class="function">ClpQuadInterface.cpp</tt>.
        It uses <tt class="function">CbcBranchUser.cpp</tt> and
        <tt class="function">CbcCompareUser.cpp</tt>
        with corresponding <tt class="function">*.hpp</tt> files.
	</td></tr><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/sos.cpp" target="_top"><tt class="filename">sos.cpp</tt></a></td><td align="left" valign="top">
	This artificially creates a Special Ordered Set problem.
	</td></tr><tr><td align="left" valign="top"><a href="http://www.coin-or.org/cgi-bin/cvsweb.cgi/COIN/Cbc/Samples/lotsize.cpp" target="_top"><tt class="filename">lotsize.cpp</tt></a></td><td align="left" valign="top">
	This artificially creates a Lot Sizing problem.
	</td></tr></tbody></table></div></div></div><div class="chapter" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="messages"></a>Chapter&nbsp;9.&nbsp;
  Messages
  </h2></div></div><div></div></div><p>
  Messages and codes passed by CBC are listed in the
  tables below.  For a complete list, see <tt class="filename">COIN/Cbc/CbcMessages.cpp</tt>. The notation used is the same as for the <tt class="function">printf</tt> in the C programming language.
  </p><div class="itemizedlist"><ul type="disc"><li>
    <tt class="computeroutput">%s</tt> is a string
    </li><li>
    <tt class="computeroutput">%d</tt> is an integer
    </li><li>
    <tt class="computeroutput">%g</tt> or <tt class="computeroutput">%f</tt>
    is a floating point value
    </li></ul></div><p>

  </p><p>There are several log levels. Setting the log level to be <i class="parameter"><tt>i</tt></i> produces the log messages for level <i class="parameter"><tt>i</tt></i> and all levels less than <i class="parameter"><tt>i</tt></i>.
 </p><div class="itemizedlist"><ul type="disc"><li>
    Log Level 0: Switches off all CBC messages, but one. 
    </li><li>
    Log Level 1: The default.  
    </li><li>
    Log Level 2: Substantial amount of information, e.g., message 15 is 
generated once per node. Can be useful when the evaluation at each node 
is slow.
    </li><li>
    Log Level 3: Tremendous amount of information, e.g., multiple messages per node. 
    </li></ul></div><div class="table"><a id="id3426171"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;
  CBC Messages Passed At Log Level 0
  </b></p><table summary="
  CBC Messages Passed At Log Level 0
  " border="0"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">
      Code
      </th><th>&nbsp;</th><th align="left">
      Text and notes
      </th><td class="auto-generated">&nbsp;</td></tr></thead><tbody><tr><td align="left">
      3007
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">No integer variables - nothing to do</tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>

      </p></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div><div class="table"><a id="id3426316"></a><p class="title"><b>Table&nbsp;9.2.&nbsp;
  CBC Messages Passed At or Above Log Level 1
  </b></p><table summary="
  CBC Messages Passed At or Above Log Level 1
  " border="0"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">
      Code
      </th><th>&nbsp;</th><th align="left">
      Text and notes
      </th><td class="auto-generated">&nbsp;</td></tr></thead><tbody><tr><td align="left">
      1
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">Search completed - best objective %g, took %d iterations and %d nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      3
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">Exiting on maximum nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      4
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Integer solution of %g found after %d iterations and %d nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      5
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Partial search - best objective %g (best possible %g), took %d iterations and %d nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      6
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      The LP relaxation is infeasible or too expensive
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      9
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Objective coefficients multiple of %g
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      10
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      After %d nodes, %d on tree, %g best solution, best possible %g
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      11
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Exiting as integer gap of %g less than %g or %g%%
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
           
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      12
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Integer solution of %g found by heuristic after %d iterations and %d nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      13
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      At root node, %d cuts changed objective from %g to %g in %d passes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      14
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Cut generator %d (%s) - %d row cuts (%d active), %d column cuts %? in %g seconds - new frequency is %d
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      16
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Integer solution of %g found by strong branching after %d iterations and %d nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      17
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      %d solved, %d variables fixed, %d tightened
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      18
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      After tightenVubs, %d variables fixed, %d tightened
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      19
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Exiting on maximum solutions
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      20
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Exiting on maximum time
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      23
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Cutoff set to %g - equivalent to best solution of %g
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      24
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Integer solution of %g found by subtree after %d iterations and %d nodes
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      26
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Setting priorities for objects %d to %d inclusive (out of %d)
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      3008
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Strong branching is fixing too many variables, too expensively!
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
     
      </p></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div><div class="table"><a id="id3427680"></a><p class="title"><b>Table&nbsp;9.3.&nbsp;
  CBC Messages Passed At or Above Log Level 2
  </b></p><table summary="
  CBC Messages Passed At or Above Log Level 2
  " border="0"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">
      Code
      </th><th>&nbsp;</th><th align="left">
      Text and notes
      </th><td class="auto-generated">&nbsp;</td></tr></thead><tbody><tr><td align="left">
      15
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Node %d Obj %g Unsat %d depth %d
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      21
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      On closer inspection node is infeasible
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      22
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      On closer inspection objective value of %g above cutoff of %g
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      23
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Allowing solution, even though largest row infeasibility is %g
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div><div class="table"><a id="id3428080"></a><p class="title"><b>Table&nbsp;9.4.&nbsp;
  CBC Messages Passed At or Above Log Level 3
  </b></p><table summary="
  CBC Messages Passed At or Above Log Level 3
  " border="0"><colgroup><col><col><col><col></colgroup><thead><tr><th align="center">
      Code
      </th><th>&nbsp;</th><th align="left">
      Text and notes
      </th><td class="auto-generated">&nbsp;</td></tr></thead><tbody><tr><td align="left">
      7
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      Strong branching on %d (%d), down %g (%d) up %g (%d) value %g
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr><tr><td align="left">
      25
      </td><td>&nbsp;</td><td align="left"><tt class="computeroutput">
      %d cleanup iterations before strong branching
      </tt></td><td class="auto-generated">&nbsp;</td></tr><tr><td colspan="2">&nbsp;</td><td align="left"><p>
      
      </p></td><td class="auto-generated">&nbsp;</td></tr></tbody></table></div></div><div class="appendix" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id3430230"></a>Appendix&nbsp;A.&nbsp;FAQ</h2></div></div><div></div></div><div class="qandaset"><table summary="Q and A Set" border="0"><colgroup><col align="left" width="1%"></colgroup><tbody><tr class="question"><td align="left" valign="top"><a id="id3429594"></a><a id="id3430253"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  What is <a href="https://projects.coin-or.org/Cbc/wiki/FAQ" target="_top">CBC</a>?
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  The <a href="http://www.coin-or.org/" target="_top">COIN-OR</a> Branch and Cut code
  is designed to be a high quality mixed integer code provided under the terms of the
  <a href="http://opensource.org/licenses/cpl.php" target="_top">Common Public License</a>.
  CBC is written in C++, and is primarily intended to be used as a callable
  library (though a rudimentary stand-alone executable exists).
  The first documented release was .90.0  The current release is version .90.0. (JF 04/01/05) 
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3430308"></a><a id="id3430312"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  What are some of the features of CBC?
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  CBC allows the use of any CGL cuts and the use of heuristics and
   specialized branching methods. (JF 04/01/05) 
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3431247"></a><a id="id3431250"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  How do I obtain and install CBC?
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  Please see the
  <a href="http://www.coin-or.org/faqs.html" target="_top">COIN-OR FAQ</a>
  for details on how to
  <a href="http://www.coin-or.org/faqs.html#ObtainSrcCode" target="_top">obtain</a>
  and
  <a href="http://www.coin-or.org/faqs.html#BuildCode" target="_top">install</a>
  COIN-OR modules. (JF 04/01/05) 
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3431296"></a><a id="id3431300"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  Is CBC reliable?
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  CBC has been tested on many problems,
  but more testing and improvement is needed before it can get to version 1.0. (JF 04/01/05) 
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3431322"></a><a id="id3431325"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  Is there any documentation for CBC?  
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  If you can see this you have the best there is:-)
  Also available is a list of
  <a href="http://www.coin-or.org/Doxygen/Cbc/" target="_top">CBC class descriptions</a> generated
  by <a href="http://www.doxygen.org/" target="_top">Doxygen</a>. (JF 04/01/05)
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3431364"></a><a id="id3431367"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  Is CBC as fast as Cplex or Xpress?
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
   No. However its design is much more flexible so advanced users
   will be able to tailor CBC to their needs. (JF 04/01/05) 
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3431390"></a><a id="id3431393"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  When will version 1.0 of CBC be available?  
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  It is expected that version 1.0 will be released in time for the 2005
  <a href="http://www.informs.org/" target="_top">INFORMS</a> annual meeting. (JF 04/01/05) 
  </p></td></tr><tr class="question"><td align="left" valign="top"><a id="id3431423"></a><a id="id3431426"></a><b>Q:. </b></td><td align="left" valign="top"><p>
  What can the community do to help?
  </p></td></tr><tr class="answer"><td align="left" valign="top"><b>A:. </b></td><td align="left" valign="top"><p>
  People from all around the world are already helping.  There are
  probably ten people who do not always post to the discussion mail list but are constantly
  "improving" the code by demanding performance or bug fixes or enhancements.  And there
  are others posting questions to discussion groups. (JF 04/01/05) 
  </p><p>
  A good start is to join the coin-discuss
  <a href="http://www.coin-or.org/mail.html" target="_top">mailing list</a> where CBC is discussed.  Some
  other possibilities include:
  </p><div class="itemizedlist"><ul type="disc"><li><p>
  Comment on the design
  </p></li><li><p>
  Give feedback on the documentation and FAQs.
  </p></li><li><p>
  Break the code, or better yet -- mend it.
  </p></li><li><p>
  Tackle any of the "to-dos" listed in the Doxyen documentation and contribute back to COIN-OR.
  </p></li></ul></div></td></tr></tbody></table></div></div><div class="appendix" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="doxygen"></a>Appendix&nbsp;B.&nbsp;Doxygen</h2></div></div><div></div></div><p>
There is Doxygen content for CBC available online at
<a href="http://www.coin-or.org/Doxygen/Cbc/index.html" target="_top">
http://www.coin-or.org/Doxygen/Cbc/index.html</a>.  A local version of the
Doxygen content can be generated from the CBC distribution.  To do so, in the
directory <tt class="filename">COIN/Cbc</tt>, enter <b class="userinput"><tt>make doc</tt></b>.
The Doxygen content will be created in the directory
<tt class="filename">COIN/Cbc/Doc/html</tt>.  The same can be done for
the COIN core, from the <tt class="filename">COIN/Coin</tt> directory.
</p></div><div class="appendix" xml:lang="en" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id3429980"></a>Appendix&nbsp;C.&nbsp;Revision History</h2></div></div><div></div></div><div class="revhistory"><table summary="Revision history" border="0" width="100%"><tbody><tr><th colspan="3" align="left" valign="top"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.21</td><td align="left">May 10, 2005</td><td align="left">RLH</td></tr><tr><td colspan="3" align="left">Fixed
 typos caught by Cole Smith, editor of the INFORMS Tutorial Book, and 
added place holders for needs-to-be-written sections, e.g., Using CGL 
with CBC.</td></tr><tr><td align="left">Revision 0.2</td><td align="left">May 2, 2005</td><td align="left">RLH</td></tr><tr><td colspan="3" align="left">Book
 chapter for CBC Tutorial at INFORMS 2005 annual meeting. Reorganized 
the content. Added CBC Messages. Changed the font type to distinguish 
functions/variables/classnames/code from text.</td></tr><tr><td align="left">Revision 0.1</td><td align="left">April 1, 2005</td><td align="left">JF</td></tr><tr><td colspan="3" align="left">First draft. The CBC documentation uses the DocBook CLP documentation created by David de la Nuez.</td></tr></tbody></table></div></div></div>
</body></html>